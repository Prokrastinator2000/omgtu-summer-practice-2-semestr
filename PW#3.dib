#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        // отсюда надо начинать реализацию задачи
        double sum = 0;
        int count = Convert.ToInt32((b - a)/step);
        int StepsOnThreads = count / threadsnumber;
        Barrier barrier = new Barrier(threadsnumber);
        Thread[] threads = new Thread[threadsnumber];
        object LockObj = new object();
        for (int i=0;i<threadsnumber;i++)
        {
            int index = i; //локальная переменная i, чтобы не было ошибок связанных с изменением i
            threads[i] = new Thread(() =>
            {
                
                double SumOnStep = 0;
                int start = index * StepsOnThreads;
                int end;
                if (index == threadsnumber-1)
                {
                    end = count;
                }
                else
                {
                    end = start + StepsOnThreads;
                }
                for (int j=start;j<end;j++)
                {
                    double x1 = a + j * step;
                    double x2 =a + (j+1)*step;
                    SumOnStep += (function(x1)+function(x2)) * step/2;
                }
                lock (LockObj) //используется не interlocked, так как работаем с типом double
                {
                    sum += SumOnStep;
                }
                barrier.SignalAndWait();
            });
            threads[i].Start();
            
        }
        foreach (Thread thread in threads)
        {
            thread.Join(); // Дождаться завершения текущего потока
        }
        return sum;
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.35"
using Xunit;
using System.Diagnostics;
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
Stopwatch Time = new Stopwatch();
var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);
double[] dataX = new double[8];
double[] dataY = new double[8];
for (double i=1e-1;i>1e-6;i=i/10)
{
Time.Start();
Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, i, 8), 1e-4);
Time.Stop();
Console.WriteLine($"Затрачено времени: {Time.Elapsed} Размер шага: {i}");
Time.Reset();
}
Console.WriteLine("Оптимальным наименьшим шагом выбран шаг: 1e-5. Выполняется меньше секунды и значительно быстрее чем с шагом: 1e-6");
int BestThread;
double MinTime = double.MaxValue;
for (int j=2;j<10;j++)
{
    double Totaltime = 0;
    for (int k=0;k<7;k++)
    {

    
    Time.Start();
    Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, 1e-5, j), 1e-4);
    Time.Stop();
    Totaltime += Time.Elapsed.TotalMilliseconds;
    Time.Reset();
    
    }
    dataX[j-2]=Totaltime/7;
    dataY[j-2]=j;
    if ((Totaltime/7) < MinTime)
    {
        MinTime = Totaltime/7;
        BestThread = j;
    }
}
Console.WriteLine($"Минимальное время: {MinTime} мс, количество потоков: {BestThread}");
ScottPlot.Plot plt = new();
plt.Add.Scatter(dataX, dataY);
plt

#!csharp

using System.Threading;
//
// Вычисление определенного интеграла
//
class DefiniteIntegralOneThread
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double Solve(double a, double b, Func<double, double> function, double step)
    {
        // отсюда надо начинать реализацию задачи
        double sum = 0;
        int count = Convert.ToInt32((b - a)/step);
        for (int i=0;i<count;i++)
        {
            double x1=a+i*step;
            double x2=x1+step;
            
            
            sum += (function(x1)+function(x2))*step/2;
            
        }
        
        return sum;
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.35"
using Xunit;
using System.Diagnostics;
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
Stopwatch Time = new Stopwatch();
var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);
double TotalTimeOneThread = 0;
for (int i=0;i<7;i++)
{
Time.Start();
Assert.Equal(0, DefiniteIntegralOneThread.Solve(-100, 100, SIN, 1e-5), 1e-4);
Time.Stop();
TotalTimeOneThread += Time.Elapsed.TotalMilliseconds;
Time.Reset();
}
Console.WriteLine(TotalTimeOneThread/7);
Console.WriteLine($"Сравнение многопоточного варианта с однопоточным\nВремя многопотока: {MinTime} мс\nВремя однопотока: {TotalTimeOneThread/7} мс\nРазница в миллисекундах: {Math.Abs(TotalTimeOneThread/7-MinTime)}\nРазница в процентах: {(Math.Abs(TotalTimeOneThread/7-MinTime)/MinTime*100)}%");

#!markdown

# Summary

**Размер шага:** 1e-5 (шаг, определяющий количество отрезков)

**Оптимальное количество потоков:** 7-8 (количество потоков, при котором программа выполняется за минимальное время)

**Скорость оптимальной многопоточной версии в сравнении с однопоточной**

1. Время выполнения многопоточной версии: от 110 до 125 миллисекунд
2. Время выполнения однопоточной версии: около 475 миллисекунд
3. Разница в процентах: около 310%
