#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

using System.Collections.Concurrent;
using System.Threading;

public interface ICommand
{
    void Execute();
}

public class ServerThread
{
    ConcurrentQueue<ICommand> commandQueue = new ConcurrentQueue<ICommand>();
    Thread thread;
    bool running = true;//для soft завершения
    bool HardStop = false;//для hard завершения

    public ServerThread()
    {
        thread = new Thread(Run);//инициализация потока
        thread.Start();
    }

    public void Run()
    {
        while (running || (!commandQueue.IsEmpty && !HardStop))
        {
            if (commandQueue.TryDequeue(out ICommand command))
            {
                try
                {
                    command.Execute();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Исключение: {ex.Message}");
                }
            }
            else
            {
                Thread.Sleep(10);
            }
        }
        Console.WriteLine("Поток остановлен.");
    }

    public void AddCommand(ICommand command)//добавление команды в очередь
    {
        commandQueue.Enqueue(command);
    }

    public void Stop()//метод для soft завершения
    {
        running = false;
    }
    public void HStop()//метод для hard завершения
    {
        HardStop = true;
    }

    public Thread GetThread() => thread;//возвращает поток
}

public class HardStopCommand : ICommand
{
    ServerThread targetThread;

    public HardStopCommand(ServerThread targetThread)//конструктор
    {
        this.targetThread = targetThread;
        
    }

    public void Execute()
    {
        if (Thread.CurrentThread == targetThread.GetThread())//проверка выполнения команды в нужном потоке
        {
            Console.WriteLine("Исполнение hard завершения потока");
            targetThread.HStop();
        }
        else
        {
            throw new InvalidOperationException("Исполнение hard завершения потока может быть произведено только в данном потоке.");
        }
    }
}

public class SoftStopCommand : ICommand
{
    ServerThread targetThread;

    public SoftStopCommand(ServerThread targetThread)
    {
        this.targetThread = targetThread;
    }

    public void Execute()
    {
        if (Thread.CurrentThread == targetThread.GetThread())//проверка выполнения команды в нужном потоке
        {
            Console.WriteLine("Исполнение soft завершения потока");
            targetThread.Stop();
        }
        else
        {
            throw new InvalidOperationException("Исполнение hard завершения потока может быть произведено только в данном потоке.");
        }
    }
}

public class SomeCommand : ICommand
{
    public void Execute()
    {
        Console.WriteLine("Исполнение некоторой команды");
    }
}

ServerThread serverThread = new ServerThread();

serverThread.AddCommand(new SomeCommand());
serverThread.AddCommand(new SoftStopCommand(serverThread));
serverThread.AddCommand(new SomeCommand());
serverThread.AddCommand(new HardStopCommand(serverThread));
serverThread.AddCommand(new SomeCommand());

serverThread.GetThread().Join();
        

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.
